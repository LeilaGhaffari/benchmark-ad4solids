#ifndef TAPENADE_H
#define TAPENADE_H

#include "../utils.h"

#define NUM_COMPONENTS_STORED_TAPENADE 15

void init_data_tapenade(double **stored_values, int Q);
void free_data_tapenade(double **stored_values);
void f_tapenade(int Q, const double mu, const double lambda, double *dXdx_init, double *dudX, double **stored_values, double *f1);
void df_tapenade(int Q, const double mu, const double lambda, double *ddudX, double **stored_values, double *df);

// -----------------------------------------------------------
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (develop) - 27 Oct 2024 18:07
*/
// -----------------------------------------------------------
static inline void MatDetAM1Symmetric_t(const double A_sym[6], double *det) {
  *det = A_sym[0] * (A_sym[1] * A_sym[2] - A_sym[3] * A_sym[3]) +
         A_sym[5] * (A_sym[3] * A_sym[4] - A_sym[5] * A_sym[2]) +
         A_sym[4] * (A_sym[5] * A_sym[3] - A_sym[4] * A_sym[1]) +
         A_sym[0] + A_sym[1] + A_sym[2] +
         A_sym[0] * A_sym[1] + A_sym[0] * A_sym[2] + A_sym[1] * A_sym[2] -
         A_sym[5] * A_sym[5] - A_sym[4] * A_sym[4] - A_sym[3] * A_sym[3];
};

static inline void MatTraceSymmetric_t(const double A_sym[6], double *trace) {
  *trace = A_sym[0] + A_sym[1] + A_sym[2];
};

static inline void compute_psi(const double e_sym[6], const double lambda, const double mu, double *energy) {
  double e2_sym[6];
  for (int i = 0; i < 6; i++) e2_sym[i] = 2 * e_sym[i];
  double detbm1;
  MatDetAM1Symmetric_t(e2_sym, &detbm1);
  double J = sqrt(detbm1 + 1);
  double logJ   = log(detbm1 + 1) / 2.;
  double trace_e;
  MatTraceSymmetric_t(e_sym, &trace_e);

  *energy = lambda * (J * J - 1) / 4 - lambda * logJ / 2 + mu * (-logJ + trace_e);
}

static inline void SymmetricMatUnpack_t(const double sym[6], double full[3][3]) {
  full[0][0] = sym[0];
  full[0][1] = sym[5];
  full[0][2] = sym[4];
  full[1][0] = sym[5];
  full[1][1] = sym[1];
  full[1][2] = sym[3];
  full[2][0] = sym[4];
  full[2][1] = sym[3];
  full[2][2] = sym[2];
}

static inline void MatMatMult_t(double alpha, const double A[3][3], const double B[3][3], double C[3][3]) {
  for (int j = 0; j < 3; j++) {
    for (int k = 0; k < 3; k++) {
      C[j][k] = 0;
      for (int m = 0; m < 3; m++) {
        C[j][k] += alpha * A[j][m] * B[m][k];
      }
    }
  }
}

static inline void SymmetricMatPack_t(const double full[3][3], double sym[6]) {
  sym[0] = full[0][0];
  sym[1] = full[1][1];
  sym[2] = full[2][2];
  sym[3] = full[1][2];
  sym[4] = full[0][2];
  sym[5] = full[0][1];
}

/*
  Differentiation of MatDetAM1Symmetric_t in reverse (adjoint) mode:
   gradient     of useful results: *det
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: det:in A_sym:in
*/
static inline void MatDetAM1Symmetric_t_b(const double A_sym[6], double A_symb[6], double *
        det, double *detb) {
    double tempb;
    double tempb0;
    double tempb1;
    int ii1;
    tempb1 = A_sym[4]*(*detb);
    tempb0 = A_sym[5]*(*detb);
    for (ii1 = 0; ii1 < 6; ++ii1)
        A_symb[ii1] = 0.0;
    A_symb[0] = A_symb[0] + (A_sym[1]*A_sym[2]-A_sym[3]*A_sym[3]+A_sym[1]+
        A_sym[2]+1.0)*(*detb);
    tempb = A_sym[0]*(*detb);
    A_symb[5] = A_symb[5] + (A_sym[3]*A_sym[4]-A_sym[5]*A_sym[2]-2*A_sym[5])*(
        *detb) + A_sym[3]*tempb1 - A_sym[2]*tempb0;
    A_symb[4] = A_symb[4] + (A_sym[5]*A_sym[3]-A_sym[4]*A_sym[1]-2*A_sym[4])*(
        *detb) + A_sym[3]*tempb0 - A_sym[1]*tempb1;
    A_symb[1] = A_symb[1] + (A_sym[0]+A_sym[2]+1.0)*(*detb) + A_sym[2]*tempb -
        A_sym[4]*tempb1;
    A_symb[2] = A_symb[2] + (A_sym[0]+A_sym[1]+1.0)*(*detb) + A_sym[1]*tempb -
        A_sym[5]*tempb0;
    A_symb[3] = A_symb[3] + A_sym[5]*tempb1 - 2*A_sym[3]*(*detb) + A_sym[4]*
        tempb0 - 2*A_sym[3]*tempb;
}

static inline void MatDetAM1Symmetric_t_nodiff(const double A_sym[6], double *det) {
    *det = A_sym[0]*(A_sym[1]*A_sym[2]-A_sym[3]*A_sym[3]) + A_sym[5]*(A_sym[3]
        *A_sym[4]-A_sym[5]*A_sym[2]) + A_sym[4]*(A_sym[5]*A_sym[3]-A_sym[4]*
        A_sym[1]) + A_sym[0] + A_sym[1] + A_sym[2] + A_sym[0]*A_sym[1] + A_sym
        [0]*A_sym[2] + A_sym[1]*A_sym[2] - A_sym[5]*A_sym[5] - A_sym[4]*A_sym[
        4] - A_sym[3]*A_sym[3];
}

/*
  Differentiation of MatTraceSymmetric_t in reverse (adjoint) mode:
   gradient     of useful results: A_sym[0:6-1] *trace
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: A_sym:in trace:in
*/
static inline void MatTraceSymmetric_t_b(const double A_sym[6], double A_symb[6], double *
        trace, double *traceb) {
    A_symb[0] = A_symb[0] + *traceb;
    A_symb[1] = A_symb[1] + *traceb;
    A_symb[2] = A_symb[2] + *traceb;
}

static inline void MatTraceSymmetric_t_nodiff(const double A_sym[6], double *trace) {
    *trace = A_sym[0] + A_sym[1] + A_sym[2];
}

/*
  Differentiation of psi in reverse (adjoint) mode:
   gradient     of useful results: *energy e_sym[0:6-1] lambda
                mu
   with respect to varying inputs: *energy e_sym[0:6-1] lambda
                mu
   RW status of diff variables: energy:(loc) *energy:in-out e_sym:(loc)
                e_sym[0:6-1]:incr lambda:incr mu:incr
   Plus diff mem management of: energy:in e_sym:in
*/
static inline void compute_grad_psi_tapenade(const double e_sym[6], double e_symb[6], const double lambda,
        double *lambdab, const double mu, double *mub, double *energy, double *energyb) {
    double e2_sym[6];
    double e2_symb[6];
    for (int i = 0; i < 6; ++i)
        e2_sym[i] = 2*e_sym[i];
    double detbm1;
    double detbm1b;
    MatDetAM1Symmetric_t_nodiff(e2_sym, &detbm1);
    double J;
    double Jb;
    J = sqrt(detbm1 + 1);
    double logJ = log(detbm1+1)/2.;
    double logJb = 0.0;
    double trace_e;
    double trace_eb;
    double TOL = 1E-5;
    MatTraceSymmetric_t_nodiff(e_sym, &trace_e);
    *lambdab = *lambdab + ((J*J-1)/4-logJ/2)*(*energyb);
    Jb = 2*J*lambda*(*energyb)/4;
    logJb = -((lambda/2+mu)*(*energyb));
    *mub = *mub + (trace_e-logJ)*(*energyb);
    trace_eb = mu*(*energyb);
    *energyb = 0.0;
    MatTraceSymmetric_t_b(e_sym, e_symb, &trace_e, &trace_eb);
    detbm1b = (fabs(detbm1 + 1) < TOL  ? logJb/((detbm1+1)*2.) : logJb/((detbm1+1)*
        2.) + Jb/(2.0*sqrt(detbm1+1)));
    MatDetAM1Symmetric_t_b(e2_sym, e2_symb, &detbm1, &detbm1b);
    for (int i = 5; i > -1; --i) {
        e_symb[i] = e_symb[i] + 2*e2_symb[i];
        e2_symb[i] = 0.0;
    }
}

/*
  Differentiation of SymmetricMatUnpack_t in forward (tangent) mode:
   variations   of useful results: full[0:3-1][0:3-1]
   with respect to varying inputs: sym[0:6-1]
   Plus diff mem management of: full:in full[0:3-1]:in sym:in
*/
static inline void SymmetricMatUnpack_t_d(const double sym[6], const double symd[6], double
        full[3][3], double fulld[3][3]) {
    int ii2;
    int ii1;
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            fulld[ii1][ii2] = 0.0;
    fulld[0][0] = symd[0];
    full[0][0] = sym[0];
    fulld[0][1] = symd[5];
    full[0][1] = sym[5];
    fulld[0][2] = symd[4];
    full[0][2] = sym[4];
    fulld[1][0] = symd[5];
    full[1][0] = sym[5];
    fulld[1][1] = symd[1];
    full[1][1] = sym[1];
    fulld[1][2] = symd[3];
    full[1][2] = sym[3];
    fulld[2][0] = symd[4];
    full[2][0] = sym[4];
    fulld[2][1] = symd[3];
    full[2][1] = sym[3];
    fulld[2][2] = symd[2];
    full[2][2] = sym[2];
}

/*
  Differentiation of MatMatMult_t in forward (tangent) mode:
   variations   of useful results: C[0:3-1][0:3-1]
   with respect to varying inputs: A[0:3-1][0:3-1] B[0:3-1][0:3-1]
   Plus diff mem management of: A:in A[0:3-1]:in B:in B[0:3-1]:in
                C:in C[0:3-1]:in
*/
static inline void MatMatMult_t_d(double alpha, double const A[3][3], double const Ad[3][3],
        double const B[3][3], double const Bd[3][3], double C[3][3], double Cd
        [3][3]) {
    int ii2;
    int ii1;
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            Cd[ii1][ii2] = 0.0;
    for (int j = 0; j < 3; ++j)
        for (int k = 0; k < 3; ++k) {
            Cd[j][k] = 0.0;
            C[j][k] = 0;
            for (int m = 0; m < 3; ++m) {
                Cd[j][k] = Cd[j][k] + alpha*(B[m][k]*Ad[j][m]+A[j][m]*Bd[m][k]
                    );
                C[j][k] += alpha*A[j][m]*B[m][k];
            }
        }
}

/*
  Differentiation of SymmetricMatPack_t in forward (tangent) mode:
   variations   of useful results: sym[0:6-1]
   with respect to varying inputs: sym[0:6-1] full[0:3-1][0:3-1]
   Plus diff mem management of: sym:in full:in full[0:3-1]:in
*/
static inline void SymmetricMatPack_t_d(double const full[3][3], double const fulld[3][3],
        double sym[6], double symd[6]) {
    symd[0] = fulld[0][0];
    sym[0] = full[0][0];
    symd[1] = fulld[1][1];
    sym[1] = full[1][1];
    symd[2] = fulld[2][2];
    sym[2] = full[2][2];
    symd[3] = fulld[1][2];
    sym[3] = full[1][2];
    symd[4] = fulld[0][2];
    sym[4] = full[0][2];
    symd[5] = fulld[0][1];
    sym[5] = full[0][1];
}

/*
  Differentiation of MatDetAM1Symmetric_t_b in forward (tangent) mode:
   variations   of useful results: A_symb[0:6-1]
   with respect to varying inputs: *detb A_sym[0:6-1]
   Plus diff mem management of: A_symb:in detb:in A_sym:in


  Differentiation of MatDetAM1Symmetric_t in reverse (adjoint) mode:
   gradient     of useful results: *det
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: det:in A_sym:in
*/
static inline void MatDetAM1Symmetric_t_b_d(const double A_sym[6], const double A_symd[6],
        double A_symb[6], double A_symbd[6], double *det, double *detb, double
        *detbd) {
    double tempb;
    double tempbd;
    double tempb0;
    double tempb0d;
    double tempb1;
    double tempb1d;
    int ii1;
    int ii10;
    double temp;
    tempb1d = (*detb)*A_symd[4] + A_sym[4]*(*detbd);
    tempb1 = A_sym[4]*(*detb);
    tempb0d = (*detb)*A_symd[5] + A_sym[5]*(*detbd);
    tempb0 = A_sym[5]*(*detb);
    for (ii1 = 0; ii1 < 6; ++ii1) {
        A_symbd[ii1] = 0.0;
        A_symb[ii1] = 0.0;
    }
    for (ii10 = 0; ii10 < 6; ++ii10)
        A_symbd[ii10] = 0.0;
    temp = A_sym[1]*A_sym[2] - A_sym[3]*A_sym[3] + A_sym[1] + A_sym[2] + 1.0;
    A_symbd[0] = (*detb)*((A_sym[2]+1.0)*A_symd[1]+(A_sym[1]+1.0)*A_symd[2]-2*
        A_sym[3]*A_symd[3]) + temp*(*detbd);
    A_symb[0] = A_symb[0] + temp*(*detb);
    tempbd = (*detb)*A_symd[0] + A_sym[0]*(*detbd);
    tempb = A_sym[0]*(*detb);
    temp = A_sym[3]*A_sym[4] - A_sym[5]*A_sym[2] - 2*A_sym[5];
    A_symbd[5] = A_symbd[5] + (*detb)*(A_sym[4]*A_symd[3]+A_sym[3]*A_symd[4]-(
        A_sym[2]+2)*A_symd[5]-A_sym[5]*A_symd[2]) + temp*(*detbd) + tempb1*
        A_symd[3] + A_sym[3]*tempb1d - tempb0*A_symd[2] - A_sym[2]*tempb0d;
    A_symb[5] = A_symb[5] + temp*(*detb) + A_sym[3]*tempb1 - A_sym[2]*tempb0;
    temp = A_sym[5]*A_sym[3] - A_sym[4]*A_sym[1] - 2*A_sym[4];
    A_symbd[4] = A_symbd[4] + (*detb)*(A_sym[3]*A_symd[5]+A_sym[5]*A_symd[3]-(
        A_sym[1]+2)*A_symd[4]-A_sym[4]*A_symd[1]) + temp*(*detbd) + tempb0*
        A_symd[3] + A_sym[3]*tempb0d - tempb1*A_symd[1] - A_sym[1]*tempb1d;
    A_symb[4] = A_symb[4] + temp*(*detb) + A_sym[3]*tempb0 - A_sym[1]*tempb1;
    A_symbd[1] = A_symbd[1] + (*detb)*(A_symd[0]+A_symd[2]) + (A_sym[0]+A_sym[
        2]+1.0)*(*detbd) + tempb*A_symd[2] + A_sym[2]*tempbd - tempb1*A_symd[4
        ] - A_sym[4]*tempb1d;
    A_symb[1] = A_symb[1] + (A_sym[0]+A_sym[2]+1.0)*(*detb) + A_sym[2]*tempb -
        A_sym[4]*tempb1;
    A_symbd[2] = A_symbd[2] + (*detb)*(A_symd[0]+A_symd[1]) + (A_sym[0]+A_sym[
        1]+1.0)*(*detbd) + tempb*A_symd[1] + A_sym[1]*tempbd - tempb0*A_symd[5
        ] - A_sym[5]*tempb0d;
    A_symb[2] = A_symb[2] + (A_sym[0]+A_sym[1]+1.0)*(*detb) + A_sym[1]*tempb -
        A_sym[5]*tempb0;
    A_symbd[3] = A_symbd[3] + tempb1*A_symd[5] + A_sym[5]*tempb1d - (2*(*detb)
        +2*tempb)*A_symd[3] - 2*A_sym[3]*(*detbd) + tempb0*A_symd[4] + A_sym[4
        ]*tempb0d - 2*A_sym[3]*tempbd;
    A_symb[3] = A_symb[3] + A_sym[5]*tempb1 - 2*A_sym[3]*(*detb) + A_sym[4]*
        tempb0 - 2*A_sym[3]*tempb;
}

/*
  Differentiation of MatDetAM1Symmetric_t_nodiff in forward (tangent) mode:
   variations   of useful results: *det
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: det:in A_sym:in
*/
static inline void MatDetAM1Symmetric_t_nodiff_d(const double A_sym[6], const double A_symd[
        6], double *det, double *detd) {
    double temp;
    double temp0;
    double temp1;
    temp = A_sym[1]*A_sym[2] - A_sym[3]*A_sym[3];
    temp0 = A_sym[3]*A_sym[4] - A_sym[5]*A_sym[2];
    temp1 = A_sym[5]*A_sym[3] - A_sym[4]*A_sym[1];
    *detd = (temp+A_sym[1]+A_sym[2]+1.0)*A_symd[0] + A_sym[0]*(A_sym[2]*A_symd
        [1]+A_sym[1]*A_symd[2]-2*A_sym[3]*A_symd[3]) + (temp0-2*A_sym[5])*
        A_symd[5] + A_sym[5]*(A_sym[4]*A_symd[3]+A_sym[3]*A_symd[4]-A_sym[2]*
        A_symd[5]-A_sym[5]*A_symd[2]) + (temp1-2*A_sym[4])*A_symd[4] + A_sym[4
        ]*(A_sym[3]*A_symd[5]+A_sym[5]*A_symd[3]-A_sym[1]*A_symd[4]-A_sym[4]*
        A_symd[1]) + (A_sym[0]+A_sym[2]+1.0)*A_symd[1] + (A_sym[0]+A_sym[1]+
        1.0)*A_symd[2] - 2*A_sym[3]*A_symd[3];
    *det = A_sym[0]*temp + A_sym[5]*temp0 + A_sym[4]*temp1 + A_sym[0] + A_sym[
        1] + A_sym[2] + A_sym[0]*A_sym[1] + A_sym[0]*A_sym[2] + A_sym[1]*A_sym
        [2] - A_sym[5]*A_sym[5] - A_sym[4]*A_sym[4] - A_sym[3]*A_sym[3];
}

/*
  Differentiation of MatTraceSymmetric_t_b in forward (tangent) mode:
   variations   of useful results: A_symb[0:6-1]
   with respect to varying inputs: *traceb
   Plus diff mem management of: traceb:in A_symb:in


  Differentiation of MatTraceSymmetric_t in reverse (adjoint) mode:
   gradient     of useful results: A_sym[0:6-1] *trace
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: A_sym:in trace:in
*/
static inline void MatTraceSymmetric_t_b_d(const double A_sym[6], double A_symb[6], double
        A_symbd[6], double *trace, double *traceb, double *tracebd) {
    int ii1;
    for (ii1 = 0; ii1 < 6; ++ii1)
        A_symbd[ii1] = 0.0;
    A_symbd[0] = *tracebd;
    A_symb[0] = A_symb[0] + *traceb;
    A_symbd[1] = A_symbd[1] + *tracebd;
    A_symb[1] = A_symb[1] + *traceb;
    A_symbd[2] = A_symbd[2] + *tracebd;
    A_symb[2] = A_symb[2] + *traceb;
}

static inline void MatTraceSymmetric_t_nodiff_nodiff(const double A_sym[6], double *trace) {
    *trace = A_sym[0] + A_sym[1] + A_sym[2];
}

/*
  Differentiation of compute_grad_psi in forward (tangent) mode:
   variations   of useful results: e_symb[0:6-1]
   with respect to varying inputs: e_sym[0:6-1] lambda mu
   Plus diff mem management of: e_sym:in e_symb:in


  Differentiation of psi in reverse (adjoint) mode:
   gradient     of useful results: *energy e_sym[0:6-1] lambda
                mu
   with respect to varying inputs: *energy e_sym[0:6-1] lambda
                mu
   RW status of diff variables: energy:(loc) *energy:in-out e_sym:(loc)
                e_sym[0:6-1]:incr lambda:incr mu:incr
   Plus diff mem management of: energy:in e_sym:in
*/
static inline void compute_grad_psi_d(const double e_sym[6], const double e_symd[6], double
        e_symb[6], double e_symbd[6], const double lambda, const double
        lambdad, double *lambdab, const double mu, const double mud, double *
        mub, double *energy, double *energyb) {
    double e2_sym[6];
    double e2_symd[6];
    double e2_symb[6];
    double e2_symbd[6];
    double fabs0;
    double result1;
    double result1d;
    double temp;
    double temp0;
    double temp1;
    int ii1;
    for (ii1 = 0; ii1 < 6; ++ii1)
        e2_symd[ii1] = 0.0;
    for (int i = 0; i < 6; ++i) {
        e2_symd[i] = 2*e_symd[i];
        e2_sym[i] = 2*e_sym[i];
    }
    double detbm1;
    double detbm1d;
    double detbm1b;
    double detbm1bd;
    MatDetAM1Symmetric_t_nodiff_d(e2_sym, e2_symd, &detbm1, &detbm1d);
    double J;
    double Jd;
    double Jb;
    double Jbd;
    double TOL = 1E-5;
    temp = sqrt(detbm1 + 1);
    Jd = (fabs(detbm1 + 1)  < TOL ? 0.0 : detbm1d/(2.0*temp));
    J = temp;
    double logJ = log(detbm1+1)/2.;
    double logJb = 0.0;
    double logJbd;
    double trace_e;
    double trace_eb;
    double trace_ebd;
    MatTraceSymmetric_t_nodiff_nodiff(e_sym, &trace_e);
    *lambdab = *lambdab + ((J*J-1)/4-logJ/2)*(*energyb);
    Jbd = (*energyb)*2*(lambda*Jd/4+J*lambdad/4);
    Jb = 2*J*lambda*(*energyb)/4;
    logJbd = -((*energyb)*(lambdad/2+mud));
    logJb = -((lambda/2+mu)*(*energyb));
    *mub = *mub + (trace_e-logJ)*(*energyb);
    trace_ebd = (*energyb)*mud;
    trace_eb = mu*(*energyb);
    *energyb = 0.0;
    MatTraceSymmetric_t_b_d(e_sym, e_symb, e_symbd, &trace_e, &trace_eb, &
                            trace_ebd);
    if (detbm1 + 1 >= 0.0)
        fabs0 = detbm1 + 1;
    else
        fabs0 = -(detbm1+1);
    temp = sqrt(detbm1 + 1);
    result1d = (fabs(detbm1 + 1)  < TOL ? 0.0 : detbm1d/(2.0*temp));
    result1 = temp;
    temp = logJb/(2.*(detbm1+1));
    temp0 = logJb/(2.*(detbm1+1));
    temp1 = Jb/(2.0*result1);
    detbm1bd = (fabs0 < TOL ? (logJbd-temp*2.*detbm1d)/(2.*(detbm1+1)) : (
        logJbd-temp0*2.*detbm1d)/(2.*(detbm1+1)) + (Jbd-temp1*2.0*result1d)/(
        2.0*result1));
    detbm1b = (fabs0 < TOL ? temp : temp0 + temp1);
    for (ii1 = 0; ii1 < 6; ++ii1)
        e2_symbd[ii1] = 0.0;
    MatDetAM1Symmetric_t_b_d(e2_sym, e2_symd, e2_symb, e2_symbd, &detbm1, &
                             detbm1b, &detbm1bd);
    for (int i = 5; i > -1; --i) {
        e_symbd[i] = e_symbd[i] + 2*e2_symbd[i];
        e_symb[i] = e_symb[i] + 2*e2_symb[i];
        e2_symbd[i] = 0.0;
        e2_symb[i] = 0.0;
    }
}

/*
  Differentiation of compute_tau in forward (tangent) mode:
   variations   of useful results: tau_sym[0:6-1]
   with respect to varying inputs: tau_sym[0:6-1] e_sym[0:6-1]
                lambda mu
   RW status of diff variables: tau_sym:(loc) tau_sym[0:6-1]:in-out
                e_sym:(loc) e_sym[0:6-1]:in lambda:in mu:in
   Plus diff mem management of: tau_sym:in e_sym:in
*/
static inline void compute_dtau_sym_fwd_tapenade(const double e_sym[6], const double e_symd[6], const double lambda, const double lambdad,
                                                 const double mu, const double mud, double tau_sym[6], double tau_symd[6]) {
    double lambdab = 0.;
    double mub = 0.;
    double energy;
    double energyb = 1.;
    double grad_psi_sym[6] = {0.};
    double grad_psi_symd[6] = {0.0};
    int ii1;
    int ii2;
    for (int i = 0; i < 6; ++i) {
        grad_psi_symd[i] = 0.0;
        grad_psi_sym[i] = 0.;
    }
    for (ii1 = 0; ii1 < 6; ++ii1)
        grad_psi_symd[ii1] = 0.0;
    compute_grad_psi_d(e_sym, e_symd, grad_psi_sym, grad_psi_symd, lambda,
                       lambdad, &lambdab, mu, mud, &mub, &energy, &energyb);
    for (int i = 3; i < 6; ++i) {
        grad_psi_symd[i] = grad_psi_symd[i]/2.;
        grad_psi_sym[i] /= 2.;
    }
    // b = 2 e + I
    double b_sym[6];
    double b_symd[6];
    for (ii1 = 0; ii1 < 6; ++ii1)
        b_symd[ii1] = 0.0;
    for (int j = 0; j < 6; ++j) {
        b_symd[j] = 2*e_symd[j];
        b_sym[j] = 2*e_sym[j] + (j < 3);
    }
    // tau = (dPsi / de) b
    double grad_psi[3][3], b[3][3], tau[3][3];
    double grad_psid[3][3], bd[3][3], taud[3][3];
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            grad_psid[ii1][ii2] = 0.0;
    SymmetricMatUnpack_t_d(grad_psi_sym, grad_psi_symd, grad_psi, grad_psid);
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            bd[ii1][ii2] = 0.0;
    SymmetricMatUnpack_t_d(b_sym, b_symd, b, bd);
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            taud[ii1][ii2] = 0.0;
    MatMatMult_t_d(1., grad_psi, grad_psid, b, bd, tau, taud);
    SymmetricMatPack_t_d(tau, taud, tau_sym, tau_symd);
}

#endif // TAPENADE_H
